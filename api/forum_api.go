/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

package api

import (
	"net/url"
	"net/http"
	"strings"
	"golang.org/x/net/context"
	"encoding/json"
	"fmt"
)

// Linger please
var (
	_ context.Context
)

type ForumApiService service


/* ForumApiService 
 Allows the owner of a fireteam thread to approve all joined members and start a private message conversation with them.
 * @param ctx context.Context Authentication Context 
 @param topicId The post id of the recruitment topic to approve.
 @return InlineResponse20010*/
func (a *ForumApiService) ForumApproveFireteamThread(ctx context.Context, topicId int64) (InlineResponse20010,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse20010
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/Recruit/Approve/{topicId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"topicId"+"}", fmt.Sprintf("%v", topicId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Gets a listing of all topics marked as part of the core group.

 @param categoryFilter The category filter.
 @param page Zero base page
 @param quickDate The date filter.
 @param sort The sort mode.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "locales" (string) Comma seperated list of locales posts must match to return in the result list. Default &#39;en&#39;
 @return InlineResponse2006*/
func (a *ForumApiService) ForumGetCoreTopicsPaged(categoryFilter int32, page int32, quickDate int32, sort int32, localVarOptionals map[string]interface{}) (InlineResponse2006,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2006
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/GetCoreTopicsPaged/{page}/{sort}/{quickDate}/{categoryFilter}/"
	localVarPath = strings.Replace(localVarPath, "{"+"categoryFilter"+"}", fmt.Sprintf("%v", categoryFilter), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"page"+"}", fmt.Sprintf("%v", page), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"quickDate"+"}", fmt.Sprintf("%v", quickDate), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sort"+"}", fmt.Sprintf("%v", sort), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["locales"], "string", "locales"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["locales"].(string); localVarOk {
		localVarQueryParams.Add("locales", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Gets tag suggestions based on partial text entry, matching them with other tags previously used in the forums.

 @param optional (nil or map[string]interface{}) with one or more of:
     @param "partialtag" (string) The partial tag input to generate suggestions from.
 @return InlineResponse2008*/
func (a *ForumApiService) ForumGetForumTagSuggestions(localVarOptionals map[string]interface{}) (InlineResponse2008,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2008
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/GetForumTagSuggestions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["partialtag"], "string", "partialtag"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["partialtag"].(string); localVarOk {
		localVarQueryParams.Add("partialtag", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Gets the specified forum poll.

 @param topicId The post id of the topic that has the poll.
 @return InlineResponse2006*/
func (a *ForumApiService) ForumGetPoll(topicId int64) (InlineResponse2006,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2006
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/Poll/{topicId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"topicId"+"}", fmt.Sprintf("%v", topicId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Returns the post specified and its immediate parent.

 @param childPostId 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "showbanned" (string) If this value is not null or empty, banned posts are requested to be returned
 @return InlineResponse2006*/
func (a *ForumApiService) ForumGetPostAndParent(childPostId int32, localVarOptionals map[string]interface{}) (InlineResponse2006,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2006
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/GetPostAndParent/{childPostId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"childPostId"+"}", fmt.Sprintf("%v", childPostId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["showbanned"], "string", "showbanned"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["showbanned"].(string); localVarOk {
		localVarQueryParams.Add("showbanned", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Returns the post specified and its immediate parent of posts that are awaiting approval.

 @param childPostId 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "showbanned" (string) If this value is not null or empty, banned posts are requested to be returned
 @return InlineResponse2006*/
func (a *ForumApiService) ForumGetPostAndParentAwaitingApproval(childPostId int32, localVarOptionals map[string]interface{}) (InlineResponse2006,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2006
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/GetPostAndParentAwaitingApproval/{childPostId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"childPostId"+"}", fmt.Sprintf("%v", childPostId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["showbanned"], "string", "showbanned"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["showbanned"].(string); localVarOk {
		localVarQueryParams.Add("showbanned", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Returns a thread of posts at the given parent, optionally returning replies to those posts as well as the original parent.

 @param getParentPost 
 @param page 
 @param pageSize 
 @param parentPostId 
 @param replySize 
 @param rootThreadMode 
 @param sortMode 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "showbanned" (string) If this value is not null or empty, banned posts are requested to be returned
 @return InlineResponse2006*/
func (a *ForumApiService) ForumGetPostsThreadedPaged(getParentPost bool, page int32, pageSize int32, parentPostId int32, replySize int32, rootThreadMode bool, sortMode int32, localVarOptionals map[string]interface{}) (InlineResponse2006,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2006
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/GetPostsThreadedPaged/{parentPostId}/{page}/{pageSize}/{replySize}/{getParentPost}/{rootThreadMode}/{sortMode}/"
	localVarPath = strings.Replace(localVarPath, "{"+"getParentPost"+"}", fmt.Sprintf("%v", getParentPost), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"page"+"}", fmt.Sprintf("%v", page), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageSize"+"}", fmt.Sprintf("%v", pageSize), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"parentPostId"+"}", fmt.Sprintf("%v", parentPostId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"replySize"+"}", fmt.Sprintf("%v", replySize), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rootThreadMode"+"}", fmt.Sprintf("%v", rootThreadMode), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sortMode"+"}", fmt.Sprintf("%v", sortMode), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["showbanned"], "string", "showbanned"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["showbanned"].(string); localVarOk {
		localVarQueryParams.Add("showbanned", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Returns a thread of posts starting at the topicId of the input childPostId, optionally returning replies to those posts as well as the original parent.

 @param childPostId 
 @param page 
 @param pageSize 
 @param replySize 
 @param rootThreadMode 
 @param sortMode 
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "showbanned" (string) If this value is not null or empty, banned posts are requested to be returned
 @return InlineResponse2006*/
func (a *ForumApiService) ForumGetPostsThreadedPagedFromChild(childPostId int32, page int32, pageSize int32, replySize int32, rootThreadMode bool, sortMode int32, localVarOptionals map[string]interface{}) (InlineResponse2006,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2006
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/GetPostsThreadedPagedFromChild/{childPostId}/{page}/{pageSize}/{replySize}/{rootThreadMode}/{sortMode}/"
	localVarPath = strings.Replace(localVarPath, "{"+"childPostId"+"}", fmt.Sprintf("%v", childPostId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"page"+"}", fmt.Sprintf("%v", page), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageSize"+"}", fmt.Sprintf("%v", pageSize), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"replySize"+"}", fmt.Sprintf("%v", replySize), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rootThreadMode"+"}", fmt.Sprintf("%v", rootThreadMode), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sortMode"+"}", fmt.Sprintf("%v", sortMode), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["showbanned"], "string", "showbanned"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["showbanned"].(string); localVarOk {
		localVarQueryParams.Add("showbanned", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Allows the caller to get a list of to 25 recruitment thread summary information objects.

 @return InlineResponse20011*/
func (a *ForumApiService) ForumGetRecruitmentThreadSummaries() (InlineResponse20011,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse20011
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/Recruit/Summaries/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Gets the post Id for the given content item&#39;s comments, if it exists.

 @param contentId 
 @return InlineResponse2007*/
func (a *ForumApiService) ForumGetTopicForContent(contentId int64) (InlineResponse2007,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2007
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/GetTopicForContent/{contentId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"contentId"+"}", fmt.Sprintf("%v", contentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Get topics from any forum.

 @param categoryFilter A category filter
 @param group The group, if any.
 @param page Zero paged page number
 @param pageSize Unused
 @param quickDate A date filter.
 @param sort The sort mode.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "locales" (string) Comma seperated list of locales posts must match to return in the result list. Default &#39;en&#39;
     @param "tagstring" (string) The tags to search, if any.
 @return InlineResponse2006*/
func (a *ForumApiService) ForumGetTopicsPaged(categoryFilter int32, group int64, page int32, pageSize int32, quickDate int32, sort int32, localVarOptionals map[string]interface{}) (InlineResponse2006,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2006
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/GetTopicsPaged/{page}/{pageSize}/{group}/{sort}/{quickDate}/{categoryFilter}/"
	localVarPath = strings.Replace(localVarPath, "{"+"categoryFilter"+"}", fmt.Sprintf("%v", categoryFilter), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group"+"}", fmt.Sprintf("%v", group), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"page"+"}", fmt.Sprintf("%v", page), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageSize"+"}", fmt.Sprintf("%v", pageSize), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"quickDate"+"}", fmt.Sprintf("%v", quickDate), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sort"+"}", fmt.Sprintf("%v", sort), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["locales"], "string", "locales"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["tagstring"], "string", "tagstring"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["locales"].(string); localVarOk {
		localVarQueryParams.Add("locales", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["tagstring"].(string); localVarOk {
		localVarQueryParams.Add("tagstring", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(nil, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Allows a user to slot themselves into a recruitment thread fireteam slot. Returns the new state of the fireteam.
 * @param ctx context.Context Authentication Context 
 @param topicId The post id of the recruitment topic you wish to join.
 @return InlineResponse2009*/
func (a *ForumApiService) ForumJoinFireteamThread(ctx context.Context, topicId int64) (InlineResponse2009,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2009
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/Recruit/Join/{topicId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"topicId"+"}", fmt.Sprintf("%v", topicId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Allows a recruitment thread owner to kick a join user from the fireteam. Returns the new state of the fireteam.
 * @param ctx context.Context Authentication Context 
 @param targetMembershipId The id of the user you wish to kick.
 @param topicId The post id of the recruitment topic you wish to join.
 @return InlineResponse2009*/
func (a *ForumApiService) ForumKickBanFireteamApplicant(ctx context.Context, targetMembershipId int64, topicId int64) (InlineResponse2009,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2009
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/Recruit/KickBan/{topicId}/{targetMembershipId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"targetMembershipId"+"}", fmt.Sprintf("%v", targetMembershipId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topicId"+"}", fmt.Sprintf("%v", topicId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* ForumApiService 
 Allows a user to remove themselves from a recruitment thread fireteam slot. Returns the new state of the fireteam.
 * @param ctx context.Context Authentication Context 
 @param topicId The post id of the recruitment topic you wish to leave.
 @return InlineResponse2009*/
func (a *ForumApiService) ForumLeaveFireteamThread(ctx context.Context, topicId int64) (InlineResponse2009,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  InlineResponse2009
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Forum/Recruit/Leave/{topicId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"topicId"+"}", fmt.Sprintf("%v", topicId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	 localVarHttpResponse, err := a.client.callAPI(r)
	 if err != nil || localVarHttpResponse == nil {
		  return successPayload, localVarHttpResponse, err
	 }
	 defer localVarHttpResponse.Body.Close()
	 if localVarHttpResponse.StatusCode >= 300 {
		return successPayload, localVarHttpResponse, reportError(localVarHttpResponse.Status)
	 }
	
	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
	 	return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

